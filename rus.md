Дамы и господа, приготовьтесь к поворотному моменту в истории веб-разработки
…

*[Барабанная дробь]*

Промисы добрались до JavaScript!

*[фейерверки, серпантин, хлопушки, беснующаяся толпа]*

В этот момент вы находитесь в одной из следующих ситуаций:

* Люди рядом радостно приветствуют вас, но вы не совсем понимаете, что за суета происходит вокруг. Возможно, вы просто не уверены в том, что четко осознаете, что такое промисы? Вы бы пожали плечами, но вес серпантина на ваших плечах не дает вам это сделать. Но не стоит волноваться, если дела обстоят именно так. Например, я проработал много лет, ничего не зная о промисах. Но, тем не менее, начать знакомство вам стоит с [этого раздела][1].
* Вы поднимаете руки вверх! Как раз вовремя! Ведь вы уже использовали промисы раньше, но разные реализации и отличающиеся API немного беспокоят вас. Хочется быстрее узнать про API нативной реализации? Тогда вам [сюда][2].
* Вы уже в курсе этой замечательной новости и немного посмеиваетесь над теми, кто прыгает от радости, услышав об этом впервые? Немного насладитесь своим превосходством, а теперь, будьте добры, изучите [справочник по API][3] 


## Из-за чего весь шум-гам? {#toc-async}

JavaScript однопоточнен, что значит, что две части кода не могут выполняться одновременно, только друг за другом. В браузере JavaScript делит поток выполнения с другими операциями. Какими именно - зависит от браузера, но, обычно, JavaScript стоит в одной очереди с отрисовкой страницы, обновлением стилей и обработкой действий пользователя (таких, как подсветка текста и взаимодействие с элементами формы). Обработка одних таких событий откладывает обработку других. 

Как человек, вы мультизадачны. Вы можете печатать на клавиатуре несколькими пальцами или вести машину и одновременно разговаривать с кем-то. Есть только одна вещь, во время которой мы не можем заниматься ничем другим. Это чиханье. Действительно, когда вы чихаете, вся ваша активность приостанавливается. Особенно это раздражает, если вы ведете машину и болтаете с кем-то. Но вы ведь не хотите писать код, склонный к насморкам и чиханью?

Наверняка, что бы разрулить асинхронность, вы использовали события и коллбеки. Вот пример использования событий для этих целей:

    var img1 = document.querySelector('.img-1');
      
    img1.addEventListener('load', function() {
      // о да, изображение загружено
    });
    
    img1.addEventListener('error', function() {
      // эхх, что-то сломалось
    });

В общем-то, этот код выглядит нормально. Мы берем изображение, добавляем пару обработчиков, и, как только один из них будет вызван, Javascript завершит свое выполнение.

К сожалению, в приведенном примере есть один неприятный нюанс: событие может произойти до того момента, как мы добавим обработчик. Для того, что бы проверить это, мы должны проверить свойство "complete" у изображения:

    var img1 = document.querySelector('.img-1');
    
    function loaded() {
      // о да, изображение загружено
    }
    
    if (img1.complete) {
      loaded();
    }
    else {
      img1.addEventListener('load', loaded);
    }
    
    img1.addEventListener('error', function() {
      // эхх, что-то сломалось
    });

В этом случае, однако, мы не сможем отследить ошибки, возникшие до того, как мы повесим обработчик на изображение. DOM попросту не дает на такой возможности. Кроме того, мы провряем загрузку только одного изображения, если же нам понадобится поработать с набором изображений, то понадобится гораздо больше кода.

## События - не всегда лучший способ {#toc-events-not-always-best}

События очень хорошо подходят для отслеживания того, что несколько раз происходит с одним и тем же объектом - нажатие клавищ, касание экрана и т.д. С такими событиями вам не важно, что произойдет до того, как вы повесите обработчик. Но когда дело доходит до асинхронного выполнения, вам очень хочется написать что-то вроде этого: 

    img1.callThisIfLoadedOrWhenLoaded(function() {
      // загружено
    }).orIfFailedCallThis(function() {
      // ошибка
    });
    
    // и…
    whenAllTheseHaveLoaded([img1, img2]).callThis(function() {
      // все загружено
    }).orIfSomeFailedCallThis(function() {
      // одна или несколько ошибок
    });

На самом деле, это именно то, что делают промисы, только с более простыми названиями методов. Если у элемента изображения есть метод "ready", возвращающий промис, мы можем сделать так: 

    img1.ready().then(function() {
      // загружено
    }, function() {
      // неудача
    });
    
    // и…
    Promise.all([img1.ready(), img2.ready()]).then(function() {
      // все изображения загружены
    }, function() {
      // не удалось загрузить одно или несколько изображений
    });

По сути, промисы похожи на события, кроме следующих моментов:
* Промис может выполниться только один раз. Кроме того, он не может поменять свой статус.
* Если промис завершился, успешно или нет, и позже вы добавите функцию обратного вызова, она будет вызвана, даже не смотря на то, что событие произошло раньше.

Это очень и очень полезно для асинхронного выполнения, ведь вас меньше интересует, в какой конкретно момент времени элемент будет доступен. Гораздо больше вас интересует реакция на происходящее.

## Терминология промисов {#toc-promise-terminology}

[Доменик Деникола][4], прочитав первый черновик этой статьи, поставил мне двойку за терминологию. Более того, он захватил меня в заложники, заставил 100 раз переписать [States and Fates][5], и еще пожаловался моим родителям. Но, не смотря на это, я все еще путаю часть терминологии. Тем не менее, вот основа:

Промисы бывают:

* выполненные: Действие, относящееся к промису, удалось выполнить.

* отклоненные: Действие, относящееся к промису, не удалось выполнить.

* ожидающие: Еще не выполненые или не отклоненные.

* отработанные: Промисы, которые были выполнены или отклонены.

Так же в спецификации есть термин **с возможность последующей обрабтки**. Это объект, похожий на промис, имеющий метод "then". Я постараюсь использовать его как можно реже.
.

## Промисы добрались до JavaScript! {#toc-javascript-promises}

На самом деле, промисы потихоньку приближались к JavaScript, например, библиотеками:

Представленные выше библиотеки и нативные промисы имеют общее стандартное поведение, называемое [Promises/A+][7]. Если вы используете jQuery, то можете использовать библиотеку [Deferreds][8]. Тем не менее, Deferreds не совместимы с Promise/A+, что делает не их [немного отличающимися в поведении и не такими полезными][9], так что будьте осторожны. jQuery так же имеет [тип объекта Промисы][10], но это только лишь подмножество  Deferred и имеет те же ограничения.

Хотя представленные реализации промисов имеют одинаковое поведение, их API отличаются. API нативных промисов в JavaScript  совпадает с API в RSVP.js. Вот как происходит создание промиса:

    var promise = new Promise(function(resolve, reject) {
      // выполнить что-то, возможно, асинхронно…
      
      if (/* все прошло без ошибок */) {
        resolve("Stuff worked!");
      }
      else {
        reject(Error("Что-то сломалось!"));
      }
    });

Конструктор принимает один аргумент - функция обратного вызова с двумя параметрами, resolve и reject. Далее выполняются действия внутри коллбека, возможно, и асинхронные, а затем, если все отработало без ошибок, вызывается resolve, иначе - reject.

Как и "throw" в JavaScript, допускается в качестве reject передавать объект типа Error. Польза такого подхода в том, что такой объект отслеживает стек вызова, что делает  отладку более приятной.

Вот как можно использовать такие промисы:

    promise.then(function(result) {
      console.log(result); // "Сработало!"
    }, function(err) {
      console.log(err); // Error: "Ошибка!"
    });

"then" принимает два аргумента, функции обратного вызова для успешного выполнения и на случай неудачи. Оба параметра опциональны, так что можно добавить функции только для одного из случаев, или же вообще не добавлять их.

Вначале промисы появились в DOM как Futures, затем были переименованы в "Promises", и окончательно попали в JavaScript. Это действительно замечатально, что они теперь в JavaScript, а не только в DOM, потому что теперь они доступные и вне браузеров, например, в Node.js (хотя промисов и нет в API Node.js, но это уже другая история).

Кроме того, промисы - это будущее JavaScript. На самом деле, все новые API для работы с DOM для асинхронных удачных/неудачных методов будут использовать промисы.  В подтверждение скажу, что их уже используют [Quota Management][11], [Font Load Events][12],
[ ServiceWorker][13], [Web MIDI][14], [Streams][15], и многие другие.

## Поддержка браузерами и polyfill {#toc-browser-support}

В некоторых браузерах уже доступна частичная поддержка промисов.
[Скачайте Canary][16], в котором промисы доступны по-умолчанию. Если же вы предпочитаете Firefox, [получите последнюю ночную сборку][17], которая так же поддерживает промисы. 

Стоит сказать,что ни один из этих браузеров не имеет полной поддержки промисов. Вы можете отслеживать [разработку Firefox в bugzilla][18], и на
[дашборде новых функций Chrome ][19].

Что бы использовать промисы в этих браузерах соотвественно спецификациям, или что бы использовать промисы в других браузерах или в Node.js, используйте [polyfill][20] (2k gzipped)

## Совсместимость с другими библиотеками {#toc-lib-compatibility}

API промисов в JavaScript будет рассматривать любую сущность с методом "then", как промисоподобную (или "thenable" - с возможностью обратного вызова). Да и вообще, за исключением `Promise.cast`, нет разницы между промисами и промисоподобными объектами. Так что если вы используете библиотеку, которая возвращает Q-промис, у вас не возникнет проблем с новыми нативными JavaScript промисами.

Так же, как я уже упомянул, deferreds в jQuery немного... бесполезны. К счастью, вы можете обернуть их в стандартные промисы, и заняться этим стоит как можно скорее:

    var jsPromise = Promise.cast($.ajax('/whatever.json'));

Тут jQuery `$.ajax` возвращает Deferred. И, так как у него есть метод "then", `Promise.cast` превращает этот объект в промис. Однако, иногда deferreds принмают несколько аргументов, например:

    var jqDeferred = $.ajax('/whatever.json');
    
    jqDeferred.then(function(response, statusText, xhrObj) {
      // ...
    }, function(xhrObj, textStatus, err) {
      // ...
    });

В этом случае промисы игнорируют все аргументы, кроме первого:

    jsPromise.then(function(response) {
      // ...
    }, function(xhrObj) {
      // ...
    });

...к счастью, это именно то, что обычно нужно вам при использовании промисов. Кроме того, помните, что jQuery не передает Error объект в rejections.

## Просто написанный сложный асинхронный код  {#toc-coding-with-promises}

Так, а давйте теперь напишем немного кода. Пускай, нам нужно:
1. Показать прелоадер для иникации начала загрузки
2. Получить JSON с сервера, в котором будут содержаться заголовок и url для нескольких глав одной истории
3. Добавить заголовок нашей странице
4. Получить каждую главу
5. Добавить главы на страницу, создав историю
6. Скрыть прелоадер

...и, кроме того, если что-то пойдет не так, сообщить юзеру об ошибке. Ну и в момент ошибки так же надо будет скрыть прелоадер, иначе, рано или поздно, у пользователя закружится голова.

Конечно, в жизни вы бы не использовали JavaScript для такого построения страницы ведь [сделать это на чистом HTML гораздо быстрее][21], однако, такая схема довольно популярна при взаимодействии с API промисов: получить разные данные из разных источников, и выполнить что-то после получения всех данных.

Давайте начнем с получения данных с сервера:

## XMLHttpRequest и промисы {#toc-promisifying-xmlhttprequest}

Старые API будут обновлены для использования промисов, если это возможно с точки зрения совместимости. `XMLHttpRequest` является главным кандидатом на такое обновление, но, все таки, давйте сами напишем небольшую функцию для выполнения GET-запроса:

    function get(url) {
      // Возвращает новый промис
      return new Promise(function(resolve, reject) {
        // Делаем стандартные XHR вещи
        var req = new XMLHttpRequest();
        req.open('GET', url);
    
        req.onload = function() {
          // Это вызовется, даже в случае 404 ошибки
          // так что проверяем статус
          if (req.status == 200) {
            // выполняем resolve промиса с полученным текстом
            resolve(req.response);
          }
          else {
            // иначе вызвыем reject с текстом статуса
            // который, возможно, даст представление об ошибке
            reject(Error(req.statusText));
          }
        };
    
        // Обрабатваем ошибки сети
        req.onerror = function() {
          reject(Error("Сетевая ошибка"));
        };
    
        // Выполняем запрос
        req.send();
      });
    }

Теперь получаем содержимое рассказа:

    get('story.json').then(function(response) {
      console.log("Выполнено", response);
    }, function(error) {
      console.error("Не удалось выполнить!", error);
    });

[Живой пример можно увидеть здесь][22], обратите внимание на вывод в консоль DevTools  результата. Теперь нам необязательно вручную набирать `XMLHttpRequest` для создания HTTP-запросов, и это здорово, потому что, чем меньше я вижу приводящий меня в ярость camel-case `XMLHttpRequest`, тем счастливее я становлюсь. 

## Цепочки {#toc-chaining}

"then" - это еще не конец. Вы можете объединять их в цепочки для изменения возвращаемых значений или же для запуска асинхронных действий одно за другим.

Изменять значения вы можете просто возращая новое значение:

    var promise = new Promise(function(resolve, reject) {
      resolve(1);
    });
    
    promise.then(function(val) {
      console.log(val); // 1
      return val + 2;
    }).then(function(val) {
      console.log(val); // 3
    });

Для более практичного и жизненного примера вернемся к строчкам:

    get('story.json').then(function(response) {
      console.log("Выполнено!", response);
    });

Ответ - JSON, но получаем мы просто текст. Нам следует изменить функцию, получающую данные, для использования JSON
`<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#responseType">responseType</a>`

    get('story.json').then(function(response) {
      return JSON.parse(response);
    }).then(function(response) {
      console.log("Ухты, JSON!", response);
    });

Так как `JSON.parse` получает один аргумент и возвращает измененное значение, то мы можем создать шорткат:

    get('story.json').then(JSON.parse).then(function(response) {
      console.log("Ухты, JSON!", response);
    });

[Посмотрите на живой пример][22] и проверьте консоль, что бы увидеть результат. На самом деле мы можем создать функцию `getJSON` совсем просто:

    function getJSON(url) {
      return get(url).then(JSON.parse);
    }

`getJSON` все так же возвращает промис, который получает данные по url и парсит результат как JSON.

### Очередь асинхронных действий  {#toc-promises-queues}

Вы так же можете использовать цепочки "then" для запуска последовательности асинхронных действий. Когда вы возвращаете что-то из функции обратного вызова у "then", выглядит это как настоящая магия. Если вы возвращаете значение, то следующий "then" будет вызван с этим значением. Если же вы возвращаете промис или промисоподобный объект, то следующий "then" дождется выполнения этого промиса, и только потом будет вызван. Например:

    getJSON('story.json').then(function(story) {
      return getJSON(story.chapterUrls[0]);
    }).then(function(chapter1) {
      console.log("Глава 1 получена!", chapter1);
    });

Тут мы выполняем асинхронный запрос к "story.json", который возвращает список URL для следующих запросов, затем мы запрашиваем данные по перовму url. Это именно тот случай, когда видно отличие промисов от стандартного использования  функций обратного вызова. Здесь мы так же можем создать короткий метод для получения глав:

    var storyPromise;
    
    function getChapter(i) {
      storyPromise = storyPromise || getJSON('story.json');
      
      return storyPromise.then(function(story) {
        return getJSON(story.chapterUrls[i]);
      })
    }
    
    // и очень просто использование:
    getChapter(0).then(function(chapter) {
      console.log(chapter);
      return getChapter(1);
    }).then(function(chapter) {
      console.log(chapter);
    });

Мы не начинаем загрузку "story.json", пока не вызовется `getChapter`. Но когда `getChapter` будет вызван в следующий раз, мы переиспользуем промис story, так что story.json загружается только один раз. Да здравствуют промисы!

## Обработка ошибок {#toc-error-handling}

Как мы видели ранее, "then" принимает два аргумента, один для успешного завершения, другой на случай возникновения ошибки (или, на языке промисов, fulfill и reject):

    get('story.json').then(function(response) {
      console.log("Успешное выполнение!", response);
    }, function(error) {
      console.log("Ошибка!", error);
    });

Так же вы можете использовать "catch":

    get('story.json').then(function(response) {
      console.log("Успшное выполнение!", response);
    }).catch(function(error) {
      console.log("Ошибка!", error);
    });

С "catch" здесь ничего особенного, просто синтаксический сахар для `then(undefined, func)`, ну и такой код немного читабельнее. Обратите внимание, что эти два примера выше - не одно и то же. Последний пример равнозначен:

    get('story.json').then(function(response) {
      console.log("Успешное выполнение!", response);
    }).then(undefined, function(error) {
      console.log("Ошибка!", error);
    });
Разница почти незаметна, но, на практике, очень полезна. 
The difference is subtle, but extremely useful. Если промису не передан аргумент reject, то выполнение передается выполнение следующему "then" с заданным reject (или "catch", так как это одно и то же). В коде `then(func1, func2)` будет вызвано только либо `func1`, либо `func2`. Однако, если будет вызвано, как `then(func1).catch(func2)`, то возможен вариант, что выполнится и `func1`, и `func2`, если во время выполнения `func1` произойдет ошибка. Так как "then" и "catch" - два разных шага цепочке выполнения. Взгляните на пример:

    asyncThing1().then(function() {
      return asyncThing2();
    }).then(function() {
      return asyncThing3();
    }).catch(function(err) {
      return asyncRecovery1();
    }).then(function() {
      return asyncThing4();
    }, function(err) {
      return asyncRecovery2();
    }).catch(function(err) {
      console.log("Не обращайте внимание!");
    }).then(function() {
      console.log("Все выполнено!");
    });

Процесс выполнения этого кода схож с обычным try/catch в JavaScript, если ошибка возникает внутри блока "try", управление передается блоку "catch". Вот подробная блок-схема того, как это происходит:

Зеленая линия - если промис выполнен, красная - если нет.

### Исключения и промисы {#toc-exceptions-and-promises}

Отказ выполнения промиса происходит в двух случаях - если ошибка произошла непосредственно в ходе его выполнения, а так же если ошибка произошла в конструкторе функции обратного вызова:

    var jsonPromise = new Promise(function(resolve, reject) {
      // JSON.parse выдает ошибку, если передать ему
      // невалидный JSON, что прервет выполнение промиса:
      resolve(JSON.parse("Это не JSON!"));
    });
    
    jsonPromise.then(function(data) {
      // Эта часть не выполнится:
      console.log("It worked!", data);
    }).catch(function(err) {
      // А вот эта выполнится:
      console.log("It failed!", err);
    });

Это полезно, когда вы хотите, что бы все, связанное с промисами,  было выполнено внутри конструктора функции обратного вызова, так что ошибки будут автоматически будут обработаны.

То же самое происходит с ошибками возникшими в функции обратного вызова, переданной в "then":

    get('/').then(JSON.parse).then(function() {
      // Эта часть не выполнится, '/' - это HTML-страница, не  JSON
      // так что JSON.parse бросит исключение
      console.log("Работает!", data);
    }).catch(function(err) {
      // и выполнится этот код
      console.log("Ошибка!", err);
    });

### Обработка ошибок на практике {#toc-errors-in-practice}
Работая с нашей историей и ее главами, мы можем использовать catch для информарования пользователя об ошибках:

    getJSON('story.json').then(function(story) {
      return getJSON(story.chapterUrls[0]);
    }).then(function(chapter1) {
      addHtmlToPage(chapter1.html);
    }).catch(function() {
      addTextToPage("Не удалось показать статью");
    }).then(function() {
      document.querySelector('.spinner').style.display = 'none';
    });
Если получение `story.chapterUrls[0]` не произойдет (например, ошибка 500 или пользователь не подключен к интернету), все последующие функции обратного вызова, включающие в себя `getJSON`, будут проигнорированы. Кроме того, проигнорируются и функция добавления chapter1.html на страницу. Вместо этого выполнение будет передано catch. В результате, "Не удалось показать статью" будет добалено на страницу в случае, если любое из предыдущих действий выполнится с ошибкой.

Как и try/catch в JavaScript, ошибка будет перехвачена, а последующий код будет выполнен, так что прелоадер будет скрыт. Так что наш код - неблокирующая асинхронная версия такого кода: 

    try {
      var story = getJSONSync('story.json');
      var chapter1 = getJSONSync(story.chapterUrls[0]);
      addHtmlToPage(chapter1.html);
    }
    catch (e) {
      addTextToPage("Не удалось показать статью");
    }
    
    document.querySelector('.spinner').style.display = 'none';

Вам может понадобиться поймать ошибку просто для логгирования, без необходимости ее обработки. Для этого просто брость ошибку еще раз, вот так:

    function getJSON(url) {
      return get(url).then(JSON.parse).catch(function(err) {
        console.log("не удалось выполнить getJSON  для", url, err);
        throw err;
      });
    }
Так нам удалось получить одну главу, но ведь мы хотим получить их все. Давайте посмотрим, как нам лучше это сделать.

## Параллеьльное и последовательное выполнение - возьмем лучшее из каждого подхода {#toc-parallelism-sequencing}

Думать асинхронно нелегко. Если вам нужно справиться с задачей как модно быстрее, пишите код так, как если бы он выполнялся синхронно:

    try {
      var story = getJSONSync('story.json');
      addHtmlToPage(story.heading);
    
      story.chapterUrls.forEach(function(chapterUrl) {
        var chapter = getJSONSync(chapterUrl);
        addHtmlToPage(chapter.html);
      });
    
      addTextToPage("Все выполнено.");
    }
    catch (err) {
      addTextToPage("Ой, сломалось: " + err.message);
    }
    
    document.querySelector('.spinner').style.display = 'none';
Это работает!([посмотреть пример][23])! Но это код синхронный, а, значит, он блокирует браузер на время своего выполнения. Для асинронного выполнения, используйте "then", что бы выполнить части кода друг за другом:

    getJSON('story.json').then(function(story) {
      addHtmlToPage(story.heading);
    
      // TODO: для кадого url в story.chapterUrls, получаем и отображаем
    }).then(function() {
      // Все выполнено!
      addTextToPage("Все выполнено");
    }).catch(function(err) {
      // Ловим ошибки, произошедшие в процессе выполнения
      addTextToPage("Ой, сломалось: " + err.message);
    }).then(function() {
      // В любом случае, скрываем прелоадер
      document.querySelector('.spinner').style.display = 'none';
    });
Но как мы можем пройтись в цикле по адресам глав и получить их по порядку? Так не **сработает**:

    story.chapterUrls.forEach(function(chapterUrl) {
      // Получаем главу
      getJSON(chapterUrl).then(function(chapter) {
        // и добавляем ее на страницу
        addHtmlToPage(chapter.html);
      });
    });
"forEach" не знает об асинхронности, так что наши главы появятся на странице в том порядке, в котором они будут загружены. И мы получим рассказ в стиле Крминиального чтива. Но это не совсем то, что нам нужно, так что давайте-ка это пофиксим…

### Задание последовательности выполнения {#toc-creating-sequences}

Мы хотим превратить наш массив `chapterUrls` в последовательность промисов. Это возможно сделать, используя "then":

    // Начнем с промиса, который всегда выполнится
    var sequence = Promise.resolve();
    
    // Пройдемся через все адреса наших глав
    story.chapterUrls.forEach(function(chapterUrl) {
      // Добавляем действия с ними в конец посдледовательности
      sequence = sequence.then(function() {
        return getJSON(chapterUrl);
      }).then(function(chapter) {
        addHtmlToPage(chapter.html);
      });
    });
Мы встретили здесь новый элемент - `Promise.resolve`, создающий промис, который будет выполнен в любом случае, внезависимсоти от значений, ему переданных. Если вы передадите ему нечто промисообразное (имеющее метод 'then'), будет создан новый промис, который выполнится или будет отклонен, так же, как и начальный промис. Фактически, это будет клон. Если же передать другое значение, например, `Promise.resolve('Привет')`, будет создан промис, который выполнится с этим значением. Если же вызвать его без передаваемого знчения, результатом выполнения промиса будет "undefined".
Кроме того, есть метод `Promise.reject(val)`, который создает промис, отклоненный с переданным значением.

Привести в порядок это код мы можем с помощью `<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">array.reduce</a>`

    // Цикл по адресам наших глав
    story.chapterUrls.reduce(function(sequence, chapterUrl) {
      // Добавляем их в конец последовательности выполнений
      return sequence.then(function() {
        return getJSON(chapterUrl);
      }).then(function(chapter) {
        addHtmlToPage(chapter.html);
      });
    }, Promise.resolve());
Этот код выполняет то же самое, что и код в предыдущем примере. Отличие только в том, что нет необходимости разделять переменную "sequence". Функция обратного вызова срабатывает для каждого элемента в массиве. Изначально, "sequence" - это `Promise.resolve()`. Но, после каждого нового вызова, "sequence" - это то, что вернул предыдущий вызов. `array.reduce` действительно полезная штука для разбиения массива на отдельные значения, которые, в нашем случае, являются промисами.

А теперь соединим все части кода вместе…

    getJSON('story.json').then(function(story) {
      addHtmlToPage(story.heading);
    
      return story.chapterUrls.reduce(function(sequence, chapterUrl) {
        // Как только последней промис статьи будет выполнен...
        return sequence.then(function() {
          // ...получаем следующую статью
          return getJSON(chapterUrl);
        }).then(function(chapter) {
          // и добавляем ее на старницу
          addHtmlToPage(chapter.html);
        });
      }, Promise.resolve());
    }).then(function() {
      // И все!
      addTextToPage("Все сделано.");
    }).catch(function(err) {
      // Ловим любые ошибки
      addTextToPage("Эх, сломалось: " + err.message);
    }).then(function() {
      // В любом случае, скрываем прелоадер
      document.querySelector('.spinner').style.display = 'none';
    });
И вот теперь у нас есть полностью асинзронная версия ранее написанного синхронного кода([живой пример][24]). Но мы можем сделать еще лучше. Сейчас наша страница грузится вот так:

![][25]</figure>
Вообще же, браузеры довольно хороши в параллельной загрузке ресурсов, так что мы немного теряем в производительности, загружая главы одну за другой. Было бы круто загрузить главы одновременно, а потом обработать их, когда они все загрузятся. К счастью, есть API для этого:

    Promise.all(arrayOfPromises).then(function(arrayOfResults) {
      //...
    });

`Promise.all` принимает массив промисов и создает промис, который будет исполнен, когда выполнятся все промисы, переданные ему. Вы получите массив возвращенных промисами значений в том же порядке, в котором вы их передали.

    getJSON('story.json').then(function(story) {
      addHtmlToPage(story.heading);
    	
			// Берем массив промисов и ждем выполнения всех
      return Promise.all(
        // Применяем метод map для массива с адресами глав
        // и получаем массив с json каждой главы
        story.chapterUrls.map(getJSON)
      );
    }).then(function(chapters) {
			// Теперь у нас есть json глав в нужном порядке. Проходим по ним в цикле...
      chapters.forEach(function(chapter) {
				// ...и добавляем их на страницу
        addHtmlToPage(chapter.html);
      });
      addTextToPage("Все выполнено.");
    }).catch(function(err) {
      // ловим все ошибки, если они были
      addTextToPage("Эх, сломалось: " + err.message);
    }).then(function() {
      document.querySelector('.spinner').style.display = 'none';
    });

В зависимости от соединения, мы можем выиграть несколько секунд с такой загрузкой, нежели чем при загрузке глав одна за другой([пример][26]). Кроме того, в последнем примере мы обошлись меньшим числом строк кода. Главы могут быть загружены в любой последовательности, но на экране они появятся в нужном порядке.
<figure>

![][27]</figure>
Тем не менее, мы можем еще улучшить производительность нашего кода. Когда главы загружаются, мы можем сразу же добавлять их на страницу. Это позволит пользователю начать читать прежде, чем загрузятся оставшиеся главы. Но, например, когда глава номер 3 загрузится, мы не должны добавлять ее на страницу, потому что пользователь может не понять, что вторая глава пропущена. Когда же будет загружена вторая глава, мы можем добавить её вместе с третьей главой и так далее.

Что бы провернуть это, мы будем получать JSON для всех наших глав одновременно, и потом создадим последовательность для добавления их на страницу:

    getJSON('story.json').then(function(story) {
      addHtmlToPage(story.heading);
    
      // Применяем метод map для массива с адресами глав
      // и получаем массив с json каждой главы
      // Теперь мы уверены, что загрузка будет осуществляется параллельно.
      return story.chapterUrls.map(getJSON)
        .reduce(function(sequence, chapterPromise) {
					// Используем reduce для связывания промисов вместе,
					// и добавления глав на старницу
          // Use reduce to chain the promises together,
          return sequence.then(function() {
						// Ждем завершения всех действий в последовательности,
						// затем ждем загрузки конкретной главы
            return chapterPromise;
          }).then(function(chapter) {
            addHtmlToPage(chapter.html);
          });
        }, Promise.resolve());
    }).then(function() {
      addTextToPage("Все сделано!");
    }).catch(function(err) {
      // Ловим все ошибки, если они произошли
      addTextToPage("Эх, сломалось: " + err.message);
    }).then(function() {
      document.querySelector('.spinner').style.display = 'none';
    });

И теперь у нас лучший вариант([смотрите пример][28])! Загрузка контента займет примерно одинаковое время, но пользователь увидит первую часть контента чуть раньше.
<figure>

![][29]</figure>
В нашем примере, так как он довольно прост, все главы появляются примерно одновременно, однако вы заметите существенную разницу, если глав будет значительно больше.

Написание этого кода в [стиле функций обратного вызова и событий Node.js][30] сделает код примерно в два раза больше, и, что главнее, сложнее для понимания. Кроме того, это не единственное применение промисов. В совокупности с другими возможностями ES6, мы получаем очень мощный и, в тоже время, простой инструмент. 

## Бонус: Промисы и Генераторы

Поговорим о кое-чем совсем новом в ES6. Хотя вам и необязательно это знать, что бы начать использовать промисы. Расценивайте это, как небольшой тизер к новым невероятным возможностям. 

В ES6 появилась такая вещь, как [генераторы][31], которая позволяет вам выйти из функции, как это обычно делает  return, но отличие в том, что позже мы сможем продолжить выполнение функции с прерванного места. Например:

    function *addGenerator() {
      var i = 0;
      while (true) {
        i += yield i;
      }
    }

Обратите внимание на символ звездочки перед именем функции, так объявляется генератор. yield - это служебное слово, создающее точку возврата/продолжения. Вот как можем использовать генераторы мы в нашей загрузке глав:

    var adder = addGenerator();
    adder.next().value; // 0
    adder.next(5).value; // 5
    adder.next(5).value; // 10
    adder.next(5).value; // 15
    adder.next(50).value; // 65

Но что это значить для промисов? Что ж, вы можете использовать эти точки возврата/продолжения для написания по сути асинхронного кода, который будет выглядеть, как синхронный. Не волнуйтесь, если не можете полностью осознать вышесказанное, лучше взгляните на пример, где есть вспомогательная функция, позволяющая использовать 'yield' для ожидания, пока промис отработает:

    function spawn(generatorFunc) {
      function continuer(verb, arg) {
        var result;
        try {
          result = generator[verb](arg);
        } catch (err) {
          return Promise.reject(err);
        }
        if (result.done) {
          return result.value;
        } else {
          return Promise.cast(result.value).then(onFulfilled, onRejected);
        }
      }
      var generator = generatorFunc();
      var onFulfilled = continuer.bind(continuer, "next");
      var onRejected = continuer.bind(continuer, "throw");
      return onFulfilled();
    }
Эта функция практически дословно взята из [библиотеки Q][32] и адаптирована мной под нативные промисы в JavaScript. С её помощью мы можем создать финальную версию нашего скрипта для загрузки глав. Добавим туда еще немного хорошего ES6, и получим вот это: 

    spawn(function *() {
      try {
				// 'yield' отлично организует асинхронное ождидание,
				// возвращая результат промиса
        let story = yield getJSON('story.json');
        addHtmlToPage(story.heading);
    
        // Применяем метод map для массива с адресами глав
      	// и получаем массив с json каждой главы
      	// Теперь мы уверены, что загрузка будет осуществляется параллельно.
        let chapterPromises = story.chapterUrls.map(getJSON);
    
        for (let chapterPromise of chapterPromises) {
				// Ждем готовности всех глав, затем добавляем их на старницу          
          let chapter = yield chapterPromise;
          addHtmlToPage(chapter.html);
        }
    
        addTextToPage("Все сделано");
      }
      catch (err) {
				// если try/catch отработали, ловим отклоненные промисы и выбрасываем здесь
        addTextToPage("Эх, сломалось: " + err.message);
      }
      document.querySelector('.spinner').style.display = 'none';
    });

Скрипт работает точно так же, как и до этого, но зато теперь он гораздо проще для понимания. Пока что он работает в Chrome
Canary ([пример][33]), но для этого необходимо в настройках найти **about:flags** и включить **Enable experimental JavaScript**.

Это активирует несколько новых возможностей ES6: промисы, генераторы, объявление переменных через let, цикл for-of. Когда мы прерываем выполнение промиса, spawn ждет выполнения промиса и возвращает окончательное значение. Если промис отклонен, точка выхода (yield) выбрасывает исключение, которое мы можем поймать в блоке try/catch, как в обычном случае. Невероятно просто для асинхронного кода!

## API промисов {#toc-api}

Все методы работают в ночных сборках Chrome и Firefox, если только не сказано об обратном. Для перечисленных ниже методов есть [полифиллы][20] для всех браузеров.

### Статические методы

`Promise.cast(promise);`
:   Возвразает promise (только если `promise.constructor == Promise`) 
    **Примечание:** Пока что доступно только в Chrome и Opera

`Promise.cast(obj);`
:   Make a promise that fulfills to obj. 
    **Примечание:** Пока что доступно только в Chrome и Opera

`Promise.resolve(thenable);`
:   Создает из thenable новый промис. Если thenable имеет метод 'then', то это промисо-образный объект. Здесь так же создается новый промис, если вы передаете нативный JavaScript промис. Единственно, что тогда он будет не так эффективен для выполнения, нежели `Promise.cast`. 

`Promise.resolve(obj);`
:   Make a promise that fulfills to obj. То же самое, что и `Promise.cast(obj)`.

`Promise.reject(obj);`
:   Создает промис, который отклонится и выбросит obj. Для полноценной отладки (например, трассировки стека), obj должен быть `instanceof Error`.

`Promise.all(array);`
:   Создает промис, который будет выполнен, если выполнится каждый элемент array, или отклонен, если будет отклонен хотя бы один элемент. Каждый элемент передается `Promise.cast`, так что массив array может состоять не только из промисов, но и промисо-подобных объектов, да и вобще объектов любого другого типа. Значение, возвращаемое при выполнении промиса - массив значенний выполнения промисов каждого элемента, в том же порядке. Значение, возвращаемое при отклонении промиса - первое отклоненное значение.
    **Примечание:** Пока что доступно только в Chrome и Opera

`Promise.race(array);`
:   Создает промис, который будет выполнен, если хотя бы один из элементов массива выполнится, и отклонен, если хотя бы один из элементов массива будет отклонен.   
    **Примечание:** Пока что доступно только в Chrome и Opera. Кроме того, полезность этого метода лично для меня не является очевидной. Я бы предпочел иметь метод, противоположный `Promise.all`, который будет отклонен, только если все элементы будут отклонены.

### Конструткор

new Promise(function(resolve, reject) {});

`resolve(thenable)`
:   Ваш промис будет выполнен/отклонен и вернет значение `thenable`.

`resolve(obj)`
:   Ваш промис будет выполнен с `obj` 

`reject(obj)`
:   Ваш промис будет отклонен и выбросит `obj`. Для полноценной отладки (например, трассировки стека), obj должен быть `instanceof Error`. Любые ошибки, выброшенные в функции обратного вызова конструктора будут сразу же переданы `reject()`.

### Методы экземпляра класса

`promise.then(onFulfilled, onRejected)`
:   `onFulfilled` будет вызван, когда/если "promise" будет выполнен. `onRejected` будет вызван, если/когда "promise" не выполнится. Оба параметра опциональны, если один или оба будут пропущены, будут вызваны следующие в цепочке `onFulfilled`/`onRejected`. Обе функции обратного вызова принимают по одному параметру - возвращаемое значение при выполнении или причина отказа выполнения. "then" возвращает новый промис, эквивалентный возвращаемому `onFulfilled`/`onRejected` значению, после передачи `Promise.resolve`. Если в функции обратного вызова произойдет ошибка и будет выброшено исключение, возвращенный промис будте отклонен с этой ошибкой.
   

`promise.catch(onRejected)`
:   Синаксический сахар для `promise.then(undefined, onRejected)` 

Огромное спасибо Anne van Kesteren, Domenic Denicola, Tom Ashworth, Remy Sharp,
Addy Osmani, Arthur Evans, и Yutaka Hirano кто помог мне вычитать статью и внести правки.

 [1]: http://www.html5rocks.com/en/tutorials/es6/promises/#toc-async

 [2]: http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promise-terminology
 [3]: http://www.html5rocks.com/en/tutorials/es6/promises/#toc-api
 [4]: https://twitter.com/domenic

 [5]: https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md
 [6]: http://en.wikipedia.org/wiki/Terry_Venables
 [7]: https://github.com/promises-aplus/promises-spec
 [8]: http://api.jquery.com/category/deferred-object/
 [9]: https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/
 [10]: http://api.jquery.com/Types/#Promise

 [11]: https://dvcs.w3.org/hg/quota/raw-file/tip/Overview.html#idl-def-StorageQuota
 [12]: http://dev.w3.org/csswg/css-font-load-events/#dom-fontface-ready

 [13]: https://github.com/slightlyoff/ServiceWorker/blob/cf459d473ae09f6994e8539113d277cbd2bce939/service_worker.ts#L17

 [14]: http://webaudio.github.io/web-midi-api/#widl-Navigator-requestMIDIAccess-Promise-MIDIOptions-options
 [15]: https://github.com/whatwg/streams#basereadablestream
 [16]: https://www.google.com/intl/en/chrome/browser/canary.html
 [17]: http://nightly.mozilla.org/
 [18]: https://bugzilla.mozilla.org/show_bug.cgi?id=918806
 [19]: http://www.chromestatus.com/features/5681726336532480
 [20]: https://github.com/jakearchibald/ES6-Promises/blob/master/README.md
 [21]: http://jakearchibald.com/2013/progressive-enhancement-is-faster/
 [22]: http://www.html5rocks.com/en/tutorials/es6/promises/story.json
 [23]: http://www.html5rocks.com/en/tutorials/es6/promises/sync-example.html
 [24]: http://www.html5rocks.com/en/tutorials/es6/promises/async-example.html
 [25]: img/promise1.gif

 [26]: http://www.html5rocks.com/en/tutorials/es6/promises/async-all-example.html
 [27]: img/promise2.gif

 [28]: http://www.html5rocks.com/en/tutorials/es6/promises/async-best-example.html
 [29]: img/promise3.gif
 [30]: https://gist.github.com/jakearchibald/0e652d95c07442f205ce
 [31]: http://wiki.ecmascript.org/doku.php?id=harmony:generators

 [32]: https://github.com/kriskowal/q/blob/db9220d714b16b96a05e9a037fa44ce581715e41/q.js#L500

 [33]: http://www.html5rocks.com/en/tutorials/es6/promises/async-generators-example.html